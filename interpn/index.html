
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="..">
      
      
        <link rel="next" href="../strobe/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.4.14">
    
    
      
        <title>2023-11-24: Building a Hypercube Interpolator (in Rust) - James Logan</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.fad675c6.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.356b1318.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#2023-11-24-building-a-hypercube-interpolator-in-rust" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="James Logan" class="md-header__button md-logo" aria-label="James Logan" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            James Logan
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              2023-11-24: Building a Hypercube Interpolator (in Rust)
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_2" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12c0-2.42-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_2">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
      </label>
    
  
</form>
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="James Logan" class="md-nav__button md-logo" aria-label="James Logan" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    James Logan
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    2023-11-24: Building a Hypercube Interpolator (in Rust)
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    2023-11-24: Building a Hypercube Interpolator (in Rust)
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#results" class="md-nav__link">
    <span class="md-ellipsis">
      Results
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rationale" class="md-nav__link">
    <span class="md-ellipsis">
      Rationale
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Rationale">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#fitpack-exists" class="md-nav__link">
    <span class="md-ellipsis">
      FITPACK exists
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#this-is-not-fitpack" class="md-nav__link">
    <span class="md-ellipsis">
      This is not FITPACK
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#this-is-something-more-specific" class="md-nav__link">
    <span class="md-ellipsis">
      This is something more specific
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tooling" class="md-nav__link">
    <span class="md-ellipsis">
      Tooling
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#implementation-selecting-a-method" class="md-nav__link">
    <span class="md-ellipsis">
      Implementation: selecting a method
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Implementation: selecting a method">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#recursive-method" class="md-nav__link">
    <span class="md-ellipsis">
      Recursive method?
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#convolutional-method" class="md-nav__link">
    <span class="md-ellipsis">
      Convolutional method?
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geometric-method" class="md-nav__link">
    <span class="md-ellipsis">
      Geometric method
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#finding-the-grid-cell" class="md-nav__link">
    <span class="md-ellipsis">
      Finding the grid cell
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Finding the grid cell">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#regular-grid" class="md-nav__link">
    <span class="md-ellipsis">
      Regular grid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rectilinear-grid" class="md-nav__link">
    <span class="md-ellipsis">
      Rectilinear grid
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bagging-the-memory-scaling" class="md-nav__link">
    <span class="md-ellipsis">
      Bagging the memory scaling
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#reinventing-the-wheel-indexing-into-an-array" class="md-nav__link">
    <span class="md-ellipsis">
      Reinventing the wheel (indexing into an array)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#doing-interpolation-with-the-geometric-method-is-easy" class="md-nav__link">
    <span class="md-ellipsis">
      Doing interpolation with the geometric method is easy
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#extending-the-geometric-method-to-extrapolation" class="md-nav__link">
    <span class="md-ellipsis">
      Extending the geometric method to extrapolation
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Extending the geometric method to extrapolation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#extrapolation-without-adjustment" class="md-nav__link">
    <span class="md-ellipsis">
      Extrapolation without adjustment
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#extrapolation-by-extending-the-grid" class="md-nav__link">
    <span class="md-ellipsis">
      Extrapolation by extending the grid?
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#extrapolation-by-a-pile-of-extra-logic" class="md-nav__link">
    <span class="md-ellipsis">
      Extrapolation by a pile of extra logic
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#extending-the-geometric-method-to-higher-dimensions" class="md-nav__link">
    <span class="md-ellipsis">
      Extending the geometric method to higher dimensions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Extending the geometric method to higher dimensions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#a-problem-in-higher-dimensions" class="md-nav__link">
    <span class="md-ellipsis">
      A problem in higher dimensions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#a-solution-in-higher-dimensions" class="md-nav__link">
    <span class="md-ellipsis">
      A solution in higher dimensions
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#next-steps" class="md-nav__link">
    <span class="md-ellipsis">
      Next Steps
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../strobe/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2023-10-21: Array Expressions without Allocation (in Rust)
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#results" class="md-nav__link">
    <span class="md-ellipsis">
      Results
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rationale" class="md-nav__link">
    <span class="md-ellipsis">
      Rationale
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Rationale">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#fitpack-exists" class="md-nav__link">
    <span class="md-ellipsis">
      FITPACK exists
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#this-is-not-fitpack" class="md-nav__link">
    <span class="md-ellipsis">
      This is not FITPACK
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#this-is-something-more-specific" class="md-nav__link">
    <span class="md-ellipsis">
      This is something more specific
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tooling" class="md-nav__link">
    <span class="md-ellipsis">
      Tooling
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#implementation-selecting-a-method" class="md-nav__link">
    <span class="md-ellipsis">
      Implementation: selecting a method
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Implementation: selecting a method">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#recursive-method" class="md-nav__link">
    <span class="md-ellipsis">
      Recursive method?
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#convolutional-method" class="md-nav__link">
    <span class="md-ellipsis">
      Convolutional method?
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geometric-method" class="md-nav__link">
    <span class="md-ellipsis">
      Geometric method
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#finding-the-grid-cell" class="md-nav__link">
    <span class="md-ellipsis">
      Finding the grid cell
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Finding the grid cell">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#regular-grid" class="md-nav__link">
    <span class="md-ellipsis">
      Regular grid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rectilinear-grid" class="md-nav__link">
    <span class="md-ellipsis">
      Rectilinear grid
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bagging-the-memory-scaling" class="md-nav__link">
    <span class="md-ellipsis">
      Bagging the memory scaling
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#reinventing-the-wheel-indexing-into-an-array" class="md-nav__link">
    <span class="md-ellipsis">
      Reinventing the wheel (indexing into an array)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#doing-interpolation-with-the-geometric-method-is-easy" class="md-nav__link">
    <span class="md-ellipsis">
      Doing interpolation with the geometric method is easy
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#extending-the-geometric-method-to-extrapolation" class="md-nav__link">
    <span class="md-ellipsis">
      Extending the geometric method to extrapolation
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Extending the geometric method to extrapolation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#extrapolation-without-adjustment" class="md-nav__link">
    <span class="md-ellipsis">
      Extrapolation without adjustment
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#extrapolation-by-extending-the-grid" class="md-nav__link">
    <span class="md-ellipsis">
      Extrapolation by extending the grid?
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#extrapolation-by-a-pile-of-extra-logic" class="md-nav__link">
    <span class="md-ellipsis">
      Extrapolation by a pile of extra logic
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#extending-the-geometric-method-to-higher-dimensions" class="md-nav__link">
    <span class="md-ellipsis">
      Extending the geometric method to higher dimensions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Extending the geometric method to higher dimensions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#a-problem-in-higher-dimensions" class="md-nav__link">
    <span class="md-ellipsis">
      A problem in higher dimensions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#a-solution-in-higher-dimensions" class="md-nav__link">
    <span class="md-ellipsis">
      A solution in higher dimensions
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#next-steps" class="md-nav__link">
    <span class="md-ellipsis">
      Next Steps
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="2023-11-24-building-a-hypercube-interpolator-in-rust">2023-11-24: Building a Hypercube Interpolator (in Rust)</h1>
<div>
  <a href=https://github.com/jlogan03>
    <img src=https://img.shields.io/badge/GitHub-100000?style=for-the-badge&logo=github&logoColor=white height="15" style="padding-right:20px">
  </a>
  <a href=https://hachyderm.io/@ponderingpothos>
    <img src=https://joinmastodon.org/logos/wordmark-black-text.svg width="105" height="15">
  </a>
</div>

<p>Edited on 2023-11-30 to add more implementation details.</p>
<h3 id="results">Results</h3>
<p>The TL;DR is that we can achieve a <strong>10-150x speedup</strong> over the reference (FITPACK via scipy)
when interpolating at a small number of observation points while <strong>eliminating allocation (!)</strong>
and staying close to perf parity for larger inputs.</p>
<p>This is particularly relevant to engineering optimization, where differentiation
workloads for interpolators typically rely on forward differences that make many
function calls with a small number of inputs.</p>
<p>Similarly, in electrical, fluid, or thermal simulation, sim times are often bound to
overhead from making many calls for a small number of outputs from real-material
property data tables through an interface such as CoolProp, and this is compounded
for optimization through such simulations.</p>
<p>Finally, some perf charts for a reference case on fair ground: interpolation
at (pre-selected) random locations inside a 20x20x20 3D grid.</p>
<p>Without preallocation of outputs for the methods described here:
<img alt="no_prealloc" src="../assets/2023-11-24/no_prealloc.svg" /></p>
<p>Unlike the scipy bindings, the methods presented here
can evaluate into preallocated output storage.</p>
<p><em>With</em> preallocation of outputs for the methods described here:
<img alt="with_prealloc" src="../assets/2023-11-24/with_prealloc.svg" /></p>
<p>Hold on - did they get <em>worse</em> with preallocation? No! This is an artifact of
the benchmarking process, but one that accentuates the value of eliminating
allocation. The benchmarks are interleaved (method 1 x100, method 2 x100, method 3 x100, ...),
so they see some performance cross-talk through allocation.</p>
<p>Eliminating allocation from the <code>interpn</code> methods <em>significantly improves scipy's performance</em>
in neighboring benchmarks, despite both methods using an un-instrumented
warmup and manually calling python's garbage collector between benchmarks. The
scipy method is still allocating, it just has less overhead - so improving <code>interpn</code>'s
memory performance by evaluating into a preallocated array helps scipy even more than it
helps <code>interpn</code>. Quite an on-the-nose example of the value of avoiding allocation in application-level code!</p>
<h3 id="rationale">Rationale</h3>
<p>First, a discussion of the state of the art, and why one might bother digging into
a field that's surely been a solved problem for some time.</p>
<h4 id="fitpack-exists">FITPACK exists</h4>
<p>As far as I'm aware, the last and only meaningful work done on general and reusable
interpolation methods for scientific computing was Dierckx's excellent 1994 textbook
and the accompanying Fortran library, FITPACK.</p>
<p>The Dierckx FITPACK library has since been absorbed into netlib alongside BLAS and LAPACK,
and remains under a homebrewed license.</p>
<p>As such, it is usually integrated into other ecosystems as a user-side dependency,
often in addition to all of the dependencies required to compile Fortran and produce
bindings in the target language.</p>
<p>Notably, the scipy project includes bindings to many FITPACK routines.
In Rust, the <a href="https://docs.rs/splinify/latest/splinify/">splinify</a> library provides
bindings to select splining routines, although I have not been able to get through
the game of dynamic dependency whackamole to get it to build successfully.</p>
<p>FITPACK supports many pieces of functionality that are out of scope here - 
in particular, Dierckx gives a thorough and performant treatment to <em>fitting</em>
the interpolator coefficients, smoothing, and surface identification,
often by finding fairly inspired phrasings of fitting problems as quadratic
programs regardless of the polynomial order of the curvefits.</p>
<h4 id="this-is-not-fitpack">This is not FITPACK</h4>
<p>The goal of this project is not to replicate all of FITPACK's functionality.
In fact, curve fitting in its entirety is out of scope.
Instead, this project will focus on the interpolation tasks common in scientific
computing, which (possibly after some uncertainty-weighted fitting) typically hold
a hard requirement on the interpolator reproducing the anchor values exactly.</p>
<p>Unlike fitting and interpolation for graphics, the correctness of the result is
the highest priority, followed by performance and ergonomics in close succession.
Smoothing or other manipulation of the data are anti-goals, as they directly
compromise correctness.</p>
<h4 id="this-is-something-more-specific">This is something more specific</h4>
<p>Good quality scientific methods for curvefitting are a larger topic than
interpolation, and while there are surely patterns in the process,
those methods also tend to be fairly bespoke to the problem under examination.</p>
<p>Functionality goals</p>
<ul>
<li>Evaluation of values (and later, gradient and hessian entries) for exact interpolators
in Rust</li>
<li>Self-contained (evaluate using only grid locations and data values)</li>
<li>Avoid the need for another program or library to provide spline knots, etc</li>
<li>Clear and permissive licensing</li>
<li>Convenient, structured, and version-controlled build process</li>
<li>Convenient inter-languge interop &amp; first-class support for bindings</li>
<li>Compatibility with embedded and high-performance systems (no allocation)</li>
<li>Smooth transition from interpolation to extrapolation (to support solvers)</li>
<li>Separation of bounds error checking from interpolation/extrapolation (to support solvers)</li>
</ul>
<h3 id="tooling">Tooling</h3>
<table>
<thead>
<tr>
<th></th>
<th>Rust</th>
<th>Python</th>
</tr>
</thead>
<tbody>
<tr>
<td>Repo</td>
<td><a href="https://github.com/jlogan03/interpn">interpn</a></td>
<td><a href="https://github.com/jlogan03/interpnpy">interpnpy</a></td>
</tr>
<tr>
<td>Docs</td>
<td><a href="https://docs.rs/interpn/latest/interpn/">Docs.rs</a></td>
<td><a href="https://interpnpy.readthedocs.io/en/latest/">readthedocs w/ mkdocs</a></td>
</tr>
<tr>
<td>Benchmark</td>
<td>Criterion</td>
<td>timeit w/ warmup</td>
</tr>
<tr>
<td>Lint</td>
<td>rustfmt &amp; clippy</td>
<td>ruff &amp; pyright</td>
</tr>
<tr>
<td>Test</td>
<td>cargo test</td>
<td>pytest &amp; mktestdocs</td>
</tr>
<tr>
<td>Release</td>
<td>release-plz &amp; cargo-semver-checks</td>
<td>maturin &amp; PyO3</td>
</tr>
</tbody>
</table>
<h3 id="implementation-selecting-a-method">Implementation: selecting a method</h3>
<p>First, there are three approaches to interpolation on a regular
or rectilinear grid that I've come across, and I had to choose one.</p>
<ul>
<li>Recursive (like FITPACK)</li>
<li>Convolution (as used in GPU libraries)</li>
<li>Geometric (no implementations I'm aware of)</li>
</ul>
<h4 id="recursive-method">Recursive method?</h4>
<p>The recursive method is fairly intuitive in addition to being
fairly performant, and making no compromise on correctness or generality.
The idea is to interpolate on one axis at a time, projecting the grid cell into
lower dimensions until finally arriving at a point.</p>
<p><img src="/assets/2023-11-24/3d_recursive.jpeg" alt="3d recursive method" width="200"/></p>
<p>It's easy enough to imagine how this recursive method would generalize to
extrapolation or to higher dimensions - do nothing, and it will handle
those cases just fine.</p>
<p>However, the amount of data that needs to be actualized at each step of the recursion
varies with the number of dimensions - <code>O(2^(ndims - 1))</code> per observation point,
plus or minus a factor of 2 depending on how hard one would like to optimize it.</p>
<p>Whether or not this is a lot depends on circumstance - but it'd sure be neat if
we could find a way to use a constant amount of storage, or at least an amount
that scales more favorably with the number of dimensions.</p>
<h4 id="convolutional-method">Convolutional method?</h4>
<p>The convolutional method doesn't make much of a diagram, but it's exceptionally fast
on GPU for image scaling, and generalizes to higher polynomials.
Unfortunately, it doesn't handle points near the edge of the grid very well, nor
extrapolation - in fact, its performance gains are directly the product of
sacrificing both correctness and generality.</p>
<p>You also have to develop the
footprint coefficients specifically for every dimensionality, and while
I'm sure there's some series formulation of it similar to how finite difference
coefficients are tabulated, I have no desire to develop that formulation.</p>
<p>It's excellent for resampling images, and there's a huge market for that,
but it's not quite what's needed for scientific computing.</p>
<h4 id="geometric-method">Geometric method</h4>
<p>The geometric method, as far as I can tell, only exists as a blurb on wikipedia
intended to give an intuitive explanation of the behavior of the better methods.</p>
<p>The idea is that each grid cell can be partitioned into sub-cells characterized
by the vector from the observation point to each grid cell vertex. This partitioning
fully fills the grid cell. A multilinear interpolation can be obtained as the sum
of the values at each grid cell multiplied by the area of the opposing sub-cell.</p>
<p><img src="/assets/2023-11-24/2d_inner.jpg" alt="2d geometric method on interior of grid cell" width="200"/></p>
<p>It's intended as an educational aid, but as an algorithm, it has some interesting
properties that merit a harder look.</p>
<p>First, the <strong>memory scaling is excellent</strong>: only <code>O(ndims)</code> stack usage is ever
needed simultaneously per observation point.</p>
<p>Second, it is better-positioned to <strong>avoid floating point error</strong> due to aggregating the
contribution from each of the grid cell vertices simultaneously (a sum of products)
rather than the recursive method's long chain of alternating subtractions, divisions,
and multiplications. In fact, division is eliminated entirely, and the longest chain
of error-prone add or sub operations is of a constant length 2 instead of length <code>ndims</code>.
The longest chain of multiplications is <code>ndims</code>, but only one division is required per
observation point regardless of dimensionality, and multiplications are a relatively
minor contributor to float error compared to addition and subtraction.</p>
<p>Third, it may actually be more correct, in a sense, than the recursive method,
because under extrapolation, it will not extrapolate the derivatives on each axis
the way that the recursive method does - instead, it produces a purely linear result
for observation points on both the interior and exterior of the grid.</p>
<h3 id="finding-the-grid-cell">Finding the grid cell</h3>
<p>Regardless of the choice of method, we'll always need to know what grid
cell the observation point lands in, in order to know which tabulated
values contribute to the interpolated result.</p>
<h4 id="regular-grid">Regular grid</h4>
<p>For regular grids where all the grid locations are evenly spaced,
this is logically easy if we're inside the grid:</p>
<div class="language-rust highlight"><pre><span></span><code><span id="__span-0-1"><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a><span class="c1">// for some observation point coordinate `x`</span>
</span><span id="__span-0-2"><a id="__codelineno-0-2" name="__codelineno-0-2" href="#__codelineno-0-2"></a><span class="kd">let</span><span class="w"> </span><span class="n">int_loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">grid_start</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">grid_step</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span>
</span></code></pre></div>
<p>It gets a little more complicated when we consider that the
point may be outside the grid, in which case we need to snap
to the grid:</p>
<div class="language-rust highlight"><pre><span></span><code><span id="__span-1-1"><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a><span class="kd">let</span><span class="w"> </span><span class="n">int_loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(((</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">grid_start</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">grid_step</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span>
</span><span id="__span-1-2"><a id="__codelineno-1-2" name="__codelineno-1-2" href="#__codelineno-1-2"></a><span class="w">              </span><span class="p">.</span><span class="n">min</span><span class="p">(</span><span class="n">grid_size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
</span><span id="__span-1-3"><a id="__codelineno-1-3" name="__codelineno-1-3" href="#__codelineno-1-3"></a><span class="w">              </span><span class="p">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></code></pre></div>
<p>But wait - we can't actually represent a value below zero as a usize,
so we need a stop over as a signed integer to represent extrapolation
below the grid without integer overflow:</p>
<div class="language-rust highlight"><pre><span></span><code><span id="__span-2-1"><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a><span class="kd">let</span><span class="w"> </span><span class="n">int_loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(((</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">grid_start</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">grid_step</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">isize</span><span class="p">)</span>
</span><span id="__span-2-2"><a id="__codelineno-2-2" name="__codelineno-2-2" href="#__codelineno-2-2"></a><span class="w">              </span><span class="p">.</span><span class="n">min</span><span class="p">(</span><span class="n">grid_size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
</span><span id="__span-2-3"><a id="__codelineno-2-3" name="__codelineno-2-3" href="#__codelineno-2-3"></a><span class="w">              </span><span class="p">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span>
</span><span id="__span-2-4"><a id="__codelineno-2-4" name="__codelineno-2-4" href="#__codelineno-2-4"></a><span class="w">              </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span>
</span></code></pre></div>
<p>We can't acturally run that yet, though, because we can't just
<code>as isize</code> and <code>as usize</code> a generic float type.</p>
<p>Converting a float to an integer also isn't exactly a clear and concise
operation - it can be done sketchily with a handful of bit shift mask
operations, but to produce a correct result in general, and to avoid
harmful edge cases, is not always possible, and we may have to
generate an error here to avoid returning an incorrect result.</p>
<p>Our observation point <code>x</code> is a generic <code>T: Float</code> using num_traits
to generalize over <code>f32</code> and <code>f64</code>. In order to also capture safe
typecasting, we can add another trait from num_traits, <code>NumCast</code>.</p>
<div class="language-rust highlight"><pre><span></span><code><span id="__span-3-1"><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a><span class="kd">let</span><span class="w"> </span><span class="n">floc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">grid_start</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">grid_step</span><span class="p">);</span><span class="w"> </span><span class="c1">// Float location</span>
</span><span id="__span-3-2"><a id="__codelineno-3-2" name="__codelineno-3-2" href="#__codelineno-3-2"></a><span class="kd">let</span><span class="w"> </span><span class="n">iloc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">isize</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">NumCast</span><span class="o">&gt;</span>::<span class="n">from</span><span class="p">(</span><span class="n">floc</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"> </span><span class="c1">// Signed integer location</span>
</span><span id="__span-3-3"><a id="__codelineno-3-3" name="__codelineno-3-3" href="#__codelineno-3-3"></a><span class="kd">let</span><span class="w"> </span><span class="n">uloc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iloc</span><span class="p">.</span><span class="n">min</span><span class="p">(</span><span class="n">grid_size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">).</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w">  </span><span class="c1">// Usable unsigned index</span>
</span></code></pre></div>
<p>That got a little weird, and there's a conspicuous <code>unwrap()</code> there:
in fact, this is expected, because if we ever try to convert, say, a NaN
value, or a value larger than <code>isize::MAX</code>, we'll have a real
un-handleable error that needs to propagate to prevent the method
from returning a genuinely incorrect result.</p>
<h4 id="rectilinear-grid">Rectilinear grid</h4>
<p>For a rectilinear grid, we have an uneven spacing of grid cells on each axis.
This means that in general, we're not sure exactly where a given observation point
lands in the grid until we check it against the grid values.</p>
<p>If we don't know anything about the location of the observation point other than
that it's more likely to be inside the grid than outside, then a bisection
search is the theoretical optimum for finding the grid index.</p>
<p>The Rust core library implements an excellent binary search, which we can use via the
<code>slice::partition_point()</code> interface.</p>
<div class="language-rust highlight"><pre><span></span><code><span id="__span-4-1"><a id="__codelineno-4-1" name="__codelineno-4-1" href="#__codelineno-4-1"></a><span class="kd">let</span><span class="w"> </span><span class="n">uloc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">grid</span><span class="p">.</span><span class="n">partition_point</span><span class="p">(</span><span class="o">|</span><span class="n">v</span><span class="o">|</span><span class="w"> </span><span class="o">*</span><span class="n">v</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
</span></code></pre></div>
<p>In practice, the simplicity gets engineered out of it to handle extrapolation
in a similar way to what happened with the regular grid method, but that's the
core of the idea.</p>
<h3 id="bagging-the-memory-scaling">Bagging the memory scaling</h3>
<p>The improved memory scaling of the geometric method only holds if we can visit 
the vertices of a given grid cell
one by one, accumulating the contribution of each one before moving to the next.
The value accumulated from each vertex doesn't depend on the others, so it works out
in terms of the flow of information - but there are <code>2^ndims</code> vertices to visit.</p>
<p>The usual solution for visiting all of them would be something like itertools'
multi_cartesian_product - but this requires the standard library, and in order to
actually access all of the indices at once, we'd still end up actualizing all <code>2^ndims</code>
vertices at once, breaking the <code>O(ndims)</code> memory scaling.</p>
<p>Starting with the index of the lower corner of the grid cell, we can represent
each vertex in terms of an array like <code>[bool; ndims]</code> where each entry is
the index offset from that lower corner to the current vertex.</p>
<p>Ultimately, we need to get one row at a time out of a table like this:</p>
<table>
<thead>
<tr>
<th>dim</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>offset</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>If we don't mind some integer operations, we can actually formulate this
table one at a time by keeping a running record of the index offset, and
flipping the index of each dimension one at a time every <code>2^dim</code> indices:</p>
<div class="language-rust highlight"><pre><span></span><code><span id="__span-5-1"><a id="__codelineno-5-1" name="__codelineno-5-1" href="#__codelineno-5-1"></a><span class="c1">// In a loop to examine the vertices one at a time...</span>
</span><span id="__span-5-2"><a id="__codelineno-5-2" name="__codelineno-5-2" href="#__codelineno-5-2"></a><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">ioffs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="kt">bool</span><span class="p">;</span><span class="w"> </span><span class="n">ndims</span><span class="p">];</span>
</span><span id="__span-5-3"><a id="__codelineno-5-3" name="__codelineno-5-3" href="#__codelineno-5-3"></a><span class="kd">let</span><span class="w"> </span><span class="n">nverts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.</span><span class="n">powi</span><span class="p">(</span><span class="n">ndims</span><span class="p">);</span>
</span><span id="__span-5-4"><a id="__codelineno-5-4" name="__codelineno-5-4" href="#__codelineno-5-4"></a><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">nverts</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-5-5"><a id="__codelineno-5-5" name="__codelineno-5-5" href="#__codelineno-5-5"></a><span class="w">    </span><span class="c1">// Every 2^nth vertex, flip which side of the cube we are examining</span>
</span><span id="__span-5-6"><a id="__codelineno-5-6" name="__codelineno-5-6" href="#__codelineno-5-6"></a><span class="w">    </span><span class="c1">// in the nth dimension.</span>
</span><span id="__span-5-7"><a id="__codelineno-5-7" name="__codelineno-5-7" href="#__codelineno-5-7"></a><span class="w">    </span><span class="c1">//</span>
</span><span id="__span-5-8"><a id="__codelineno-5-8" name="__codelineno-5-8" href="#__codelineno-5-8"></a><span class="w">    </span><span class="c1">// Because i % 2^n has double the period for each sequential n,</span>
</span><span id="__span-5-9"><a id="__codelineno-5-9" name="__codelineno-5-9" href="#__codelineno-5-9"></a><span class="w">    </span><span class="c1">// and their phase is only aligned once every 2^n for the largest</span>
</span><span id="__span-5-10"><a id="__codelineno-5-10" name="__codelineno-5-10" href="#__codelineno-5-10"></a><span class="w">    </span><span class="c1">// n in the set, this is guaranteed to produce a path that visits</span>
</span><span id="__span-5-11"><a id="__codelineno-5-11" name="__codelineno-5-11" href="#__codelineno-5-11"></a><span class="w">    </span><span class="c1">// each vertex exactly once.</span>
</span><span id="__span-5-12"><a id="__codelineno-5-12" name="__codelineno-5-12" href="#__codelineno-5-12"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">ndims</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-5-13"><a id="__codelineno-5-13" name="__codelineno-5-13" href="#__codelineno-5-13"></a><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">flip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2_</span><span class="k">usize</span><span class="p">.</span><span class="n">pow</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</span><span id="__span-5-14"><a id="__codelineno-5-14" name="__codelineno-5-14" href="#__codelineno-5-14"></a><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">flip</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-5-15"><a id="__codelineno-5-15" name="__codelineno-5-15" href="#__codelineno-5-15"></a><span class="w">            </span><span class="n">ioffs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="n">ioffs</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span><span id="__span-5-16"><a id="__codelineno-5-16" name="__codelineno-5-16" href="#__codelineno-5-16"></a><span class="w">        </span><span class="p">}</span>
</span><span id="__span-5-17"><a id="__codelineno-5-17" name="__codelineno-5-17" href="#__codelineno-5-17"></a><span class="w">    </span><span class="p">}</span>
</span><span id="__span-5-18"><a id="__codelineno-5-18" name="__codelineno-5-18" href="#__codelineno-5-18"></a>
</span><span id="__span-5-19"><a id="__codelineno-5-19" name="__codelineno-5-19" href="#__codelineno-5-19"></a><span class="w">    </span><span class="c1">// ... then accumulate the contribution of the vertex</span>
</span><span id="__span-5-20"><a id="__codelineno-5-20" name="__codelineno-5-20" href="#__codelineno-5-20"></a><span class="p">}</span>
</span></code></pre></div>
<p>So with that, we have no-std and limited-memory version of
multi_cartesian_product specialized to this usage, and
we only need to store a tiny number of values to run it.</p>
<p>The cost comes in compute, but ultimately, integer mod with a base that is
a power of 2 is not expensive. In any case, this compute has to happen
<em>somewhere</em>, and it may as well be here.</p>
<p>Doing this mod operation with manually-assembled bit-shift operations does
not improve performance. I haven't looked too hard at the assembly, but
I'd bet that's because the compiler knows what's up.</p>
<h3 id="reinventing-the-wheel-indexing-into-an-array">Reinventing the wheel (indexing into an array)</h3>
<p>Ok, well, now that we have the vertex, we're still not quite ready to
start accumulating the contribution. First, we need to get the grid
value associated with that vertex.</p>
<p>Without any external dependencies on array libraries, that means
writing our own array indexing.</p>
<p>Assuming we've got a contiguous input array that was formulated from
C-style interleaved inputs from an <code>N x M</code> coordinate grid,
the values are ordered like this:</p>
<div class="language-text highlight"><pre><span></span><code><span id="__span-6-1"><a id="__codelineno-6-1" name="__codelineno-6-1" href="#__codelineno-6-1"></a>[
</span><span id="__span-6-2"><a id="__codelineno-6-2" name="__codelineno-6-2" href="#__codelineno-6-2"></a>  z(x0, y0), ... , z(x0, yM),
</span><span id="__span-6-3"><a id="__codelineno-6-3" name="__codelineno-6-3" href="#__codelineno-6-3"></a>  z(x1, y0), ... , z(x1, yM), 
</span><span id="__span-6-4"><a id="__codelineno-6-4" name="__codelineno-6-4" href="#__codelineno-6-4"></a>  ...
</span><span id="__span-6-5"><a id="__codelineno-6-5" name="__codelineno-6-5" href="#__codelineno-6-5"></a>  z(xN, y0), ... , z(xN, yM)
</span><span id="__span-6-6"><a id="__codelineno-6-6" name="__codelineno-6-6" href="#__codelineno-6-6"></a>]
</span></code></pre></div>
<p>In order to know where to find each row, column, or whatever you call the
flakes of an array in the higher dimensions, we need to skip the cumulative
product of the sizes of all the higher dimensions in order to find the next
flake of the lower dimension.</p>
<div class="language-rust highlight"><pre><span></span><code><span id="__span-7-1"><a id="__codelineno-7-1" name="__codelineno-7-1" href="#__codelineno-7-1"></a><span class="c1">// Sometime before the loop, accumulate the cumulative product</span>
</span><span id="__span-7-2"><a id="__codelineno-7-2" name="__codelineno-7-2" href="#__codelineno-7-2"></a><span class="c1">// of sizes of each dimension of the grid</span>
</span><span id="__span-7-3"><a id="__codelineno-7-3" name="__codelineno-7-3" href="#__codelineno-7-3"></a>
</span><span id="__span-7-4"><a id="__codelineno-7-4" name="__codelineno-7-4" href="#__codelineno-7-4"></a><span class="c1">// Populate cumulative product of higher dimensions for indexing.</span>
</span><span id="__span-7-5"><a id="__codelineno-7-5" name="__codelineno-7-5" href="#__codelineno-7-5"></a><span class="c1">//</span>
</span><span id="__span-7-6"><a id="__codelineno-7-6" name="__codelineno-7-6" href="#__codelineno-7-6"></a><span class="c1">// Each entry is the cumulative product of the size of dimensions</span>
</span><span id="__span-7-7"><a id="__codelineno-7-7" name="__codelineno-7-7" href="#__codelineno-7-7"></a><span class="c1">// higher than this one, which is the stride between blocks</span>
</span><span id="__span-7-8"><a id="__codelineno-7-8" name="__codelineno-7-8" href="#__codelineno-7-8"></a><span class="c1">// relating to a given index along each dimension.</span>
</span><span id="__span-7-9"><a id="__codelineno-7-9" name="__codelineno-7-9" href="#__codelineno-7-9"></a><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">dimprod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1_</span><span class="n">usise</span><span class="p">;</span><span class="w"> </span><span class="n">ndims</span><span class="p">];</span>
</span><span id="__span-7-10"><a id="__codelineno-7-10" name="__codelineno-7-10" href="#__codelineno-7-10"></a><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
</span><span id="__span-7-11"><a id="__codelineno-7-11" name="__codelineno-7-11" href="#__codelineno-7-11"></a><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">ndims</span><span class="p">).</span><span class="n">for_each</span><span class="p">(</span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-7-12"><a id="__codelineno-7-12" name="__codelineno-7-12" href="#__codelineno-7-12"></a><span class="w">    </span><span class="n">dimprod</span><span class="p">[</span><span class="n">ndims</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">acc</span><span class="p">;</span>
</span><span id="__span-7-13"><a id="__codelineno-7-13" name="__codelineno-7-13" href="#__codelineno-7-13"></a><span class="w">    </span><span class="n">acc</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">dims</span><span class="p">[</span><span class="n">ndims</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
</span><span id="__span-7-14"><a id="__codelineno-7-14" name="__codelineno-7-14" href="#__codelineno-7-14"></a><span class="p">});</span><span class="w">  </span><span class="c1">// This doesn&#39;t quite work as a .fold()</span>
</span><span id="__span-7-15"><a id="__codelineno-7-15" name="__codelineno-7-15" href="#__codelineno-7-15"></a>
</span><span id="__span-7-16"><a id="__codelineno-7-16" name="__codelineno-7-16" href="#__codelineno-7-16"></a><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">nverts</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-7-17"><a id="__codelineno-7-17" name="__codelineno-7-17" href="#__codelineno-7-17"></a><span class="w">    </span><span class="c1">//  ... sometime later in the loop where we did some shenanigans</span>
</span><span id="__span-7-18"><a id="__codelineno-7-18" name="__codelineno-7-18" href="#__codelineno-7-18"></a><span class="w">    </span><span class="c1">//      with a mod operation to find the `ioffs` entries</span>
</span><span id="__span-7-19"><a id="__codelineno-7-19" name="__codelineno-7-19" href="#__codelineno-7-19"></a>
</span><span id="__span-7-20"><a id="__codelineno-7-20" name="__codelineno-7-20" href="#__codelineno-7-20"></a><span class="w">    </span><span class="c1">// Accumulate the index into the value array,</span>
</span><span id="__span-7-21"><a id="__codelineno-7-21" name="__codelineno-7-21" href="#__codelineno-7-21"></a><span class="w">    </span><span class="c1">// saturating to the bound if the resulting index would be outside.</span>
</span><span id="__span-7-22"><a id="__codelineno-7-22" name="__codelineno-7-22" href="#__codelineno-7-22"></a><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</span><span id="__span-7-23"><a id="__codelineno-7-23" name="__codelineno-7-23" href="#__codelineno-7-23"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">ndims</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-7-24"><a id="__codelineno-7-24" name="__codelineno-7-24" href="#__codelineno-7-24"></a><span class="w">        </span><span class="n">k</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dimprod</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</span><span id="__span-7-25"><a id="__codelineno-7-25" name="__codelineno-7-25" href="#__codelineno-7-25"></a><span class="w">            </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">origin</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ioffs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">).</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">dims</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">saturating_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span><span id="__span-7-26"><a id="__codelineno-7-26" name="__codelineno-7-26" href="#__codelineno-7-26"></a><span class="w">    </span><span class="p">}</span>
</span><span id="__span-7-27"><a id="__codelineno-7-27" name="__codelineno-7-27" href="#__codelineno-7-27"></a>
</span><span id="__span-7-28"><a id="__codelineno-7-28" name="__codelineno-7-28" href="#__codelineno-7-28"></a><span class="w">    </span><span class="c1">// ... then, maybe, finally, accumulate the contribution of the vertex</span>
</span><span id="__span-7-29"><a id="__codelineno-7-29" name="__codelineno-7-29" href="#__codelineno-7-29"></a><span class="p">}</span>
</span></code></pre></div>
<p>That expanded a bit from concept to execution, but it's also one of the places
where Rust's particulars shine: the <code>saturating_{op}</code> functions are really excellent for doing safe indexing, and while they may represent extra
operations in some places, usually wherever there's a <code>saturating_{op}</code>,
there's a slice indexing bounds check that can be optimized out.</p>
<p>And since we're examining extrapolation as well as interpolation,
these indexing edge cases aren't academic -
they're the product.</p>
<h3 id="doing-interpolation-with-the-geometric-method-is-easy">Doing interpolation with the geometric method is easy</h3>
<div class="language-rust highlight"><pre><span></span><code><span id="__span-8-1"><a id="__codelineno-8-1" name="__codelineno-8-1" href="#__codelineno-8-1"></a><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">interped</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span>::<span class="n">zero</span><span class="p">();</span><span class="w"> </span><span class="c1">// The accumulated interpolated value</span>
</span><span id="__span-8-2"><a id="__codelineno-8-2" name="__codelineno-8-2" href="#__codelineno-8-2"></a><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">nverts</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-8-3"><a id="__codelineno-8-3" name="__codelineno-8-3" href="#__codelineno-8-3"></a><span class="w">    </span><span class="c1">//  ... sometime later in the loop where we did some shenanigans</span>
</span><span id="__span-8-4"><a id="__codelineno-8-4" name="__codelineno-8-4" href="#__codelineno-8-4"></a><span class="w">    </span><span class="c1">//      with a mod operation to find the `ioffs` entries</span>
</span><span id="__span-8-5"><a id="__codelineno-8-5" name="__codelineno-8-5" href="#__codelineno-8-5"></a><span class="w">    </span><span class="c1">//      and after we hand-roll array indexing</span>
</span><span id="__span-8-6"><a id="__codelineno-8-6" name="__codelineno-8-6" href="#__codelineno-8-6"></a>
</span><span id="__span-8-7"><a id="__codelineno-8-7" name="__codelineno-8-7" href="#__codelineno-8-7"></a><span class="w">    </span><span class="c1">// Get the value at this vertex</span>
</span><span id="__span-8-8"><a id="__codelineno-8-8" name="__codelineno-8-8" href="#__codelineno-8-8"></a><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vals</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
</span><span id="__span-8-9"><a id="__codelineno-8-9" name="__codelineno-8-9" href="#__codelineno-8-9"></a>
</span><span id="__span-8-10"><a id="__codelineno-8-10" name="__codelineno-8-10" href="#__codelineno-8-10"></a><span class="w">    </span><span class="c1">// Find the vector from the opposite vertex to the observation point</span>
</span><span id="__span-8-11"><a id="__codelineno-8-11" name="__codelineno-8-11" href="#__codelineno-8-11"></a><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">dxs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">T</span>::<span class="n">zero</span><span class="p">();</span><span class="w"> </span><span class="n">ndims</span><span class="p">];</span>
</span><span id="__span-8-12"><a id="__codelineno-8-12" name="__codelineno-8-12" href="#__codelineno-8-12"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">ndims</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-8-13"><a id="__codelineno-8-13" name="__codelineno-8-13" href="#__codelineno-8-13"></a><span class="w">        </span><span class="c1">// Populate dxs[j] with the (unsigned) vector</span>
</span><span id="__span-8-14"><a id="__codelineno-8-14" name="__codelineno-8-14" href="#__codelineno-8-14"></a><span class="w">    </span><span class="p">}</span>
</span><span id="__span-8-15"><a id="__codelineno-8-15" name="__codelineno-8-15" href="#__codelineno-8-15"></a>
</span><span id="__span-8-16"><a id="__codelineno-8-16" name="__codelineno-8-16" href="#__codelineno-8-16"></a><span class="w">    </span><span class="c1">// Accumulate contribution from this vertex</span>
</span><span id="__span-8-17"><a id="__codelineno-8-17" name="__codelineno-8-17" href="#__codelineno-8-17"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">extrapolating</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-8-18"><a id="__codelineno-8-18" name="__codelineno-8-18" href="#__codelineno-8-18"></a><span class="w">        </span><span class="c1">// Interpolating is easy! Just do a cumulative product</span>
</span><span id="__span-8-19"><a id="__codelineno-8-19" name="__codelineno-8-19" href="#__codelineno-8-19"></a><span class="w">        </span><span class="c1">// to get the sub-cell volume for this vertex which</span>
</span><span id="__span-8-20"><a id="__codelineno-8-20" name="__codelineno-8-20" href="#__codelineno-8-20"></a><span class="w">        </span><span class="c1">// tells us its weight in the weighted average</span>
</span><span id="__span-8-21"><a id="__codelineno-8-21" name="__codelineno-8-21" href="#__codelineno-8-21"></a><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">vol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dxs</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">fold</span><span class="p">(</span><span class="n">T</span>::<span class="n">one</span><span class="p">(),</span><span class="w"> </span><span class="o">|</span><span class="n">acc</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">);</span>
</span><span id="__span-8-22"><a id="__codelineno-8-22" name="__codelineno-8-22" href="#__codelineno-8-22"></a><span class="w">        </span><span class="n">interped</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">interped</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vol</span><span class="p">;</span>
</span><span id="__span-8-23"><a id="__codelineno-8-23" name="__codelineno-8-23" href="#__codelineno-8-23"></a><span class="w">    </span><span class="p">}</span>
</span><span id="__span-8-24"><a id="__codelineno-8-24" name="__codelineno-8-24" href="#__codelineno-8-24"></a><span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-8-25"><a id="__codelineno-8-25" name="__codelineno-8-25" href="#__codelineno-8-25"></a><span class="w">      </span><span class="c1">// Extrapolating</span>
</span><span id="__span-8-26"><a id="__codelineno-8-26" name="__codelineno-8-26" href="#__codelineno-8-26"></a><span class="w">      </span><span class="c1">// ...</span>
</span><span id="__span-8-27"><a id="__codelineno-8-27" name="__codelineno-8-27" href="#__codelineno-8-27"></a><span class="w">    </span><span class="p">}</span>
</span><span id="__span-8-28"><a id="__codelineno-8-28" name="__codelineno-8-28" href="#__codelineno-8-28"></a><span class="p">}</span>
</span><span id="__span-8-29"><a id="__codelineno-8-29" name="__codelineno-8-29" href="#__codelineno-8-29"></a>
</span><span id="__span-8-30"><a id="__codelineno-8-30" name="__codelineno-8-30" href="#__codelineno-8-30"></a><span class="c1">// Return the interpolated total, dividing through by the total</span>
</span><span id="__span-8-31"><a id="__codelineno-8-31" name="__codelineno-8-31" href="#__codelineno-8-31"></a><span class="c1">// cell volume just one time at the end</span>
</span><span id="__span-8-32"><a id="__codelineno-8-32" name="__codelineno-8-32" href="#__codelineno-8-32"></a><span class="n">interped</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">cell_vol</span>
</span></code></pre></div>
<h3 id="extending-the-geometric-method-to-extrapolation">Extending the geometric method to extrapolation</h3>
<p>The geometric method sounds good on paper, but let's see how it holds up
in a practical implementation. In particular, we need it to work well 
(1) in extrapolation and (2) in higher dimensions.</p>
<p>I filled up a notebook with doodles and algebra figuring this out, but I'll spare
us both the excessive summations and keep the abuses of notation between me
and the graph paper. Visual depictions of computational geometry fare better than obfuscatory equation soup, anyway.</p>
<h4 id="extrapolation-without-adjustment">Extrapolation without adjustment</h4>
<p>Let's try extrapolating in 2D.</p>
<p><img src="/assets/2023-11-24/2d_extrap.jpg" alt="2d geometric method extrapolated in corner region" width="200"/></p>
<p>Well, that didn't work - at least not without some extra handling.</p>
<h4 id="extrapolation-by-extending-the-grid">Extrapolation by extending the grid?</h4>
<p>One option would be to extend the grid cell to include the full area including the
observation point. </p>
<p>On inspection, this is the same as the recursive method - we
would need to treat each dimension in extrapolation one at a time, actualize the
new grid, then finish the interpolation (which, in this case, would just be taking
one corner of the grid as the final value).</p>
<p>That's not great. For one thing, it would have a worse memory scaling, and I'd be
implementing both methods instead of just one. For another, it produces a dubious result
when the grid data describes a nonlinear function: the extrapolation would twist
the grid cell like a potato chip, effectively extrapolating the derivatives as
well as the value and producing a kind of <em>quadratic</em> extrapolation instead of
a linear one.</p>
<p>There's a better way, but it involves chewing a bit of glass.</p>
<h4 id="extrapolation-by-a-pile-of-extra-logic">Extrapolation by a pile of extra logic</h4>
<p>I don't have a good name for this process. It's a turducken of constructive
geometry and plain algebra - basically reverse-engineering
the failure of the method to naturally extend to extrapolation, and eliminating
those failures.</p>
<p>We clearly need to zero-out the contribution from vertex <code>A</code> as we move into
extrapolation to produce the same result we would get by taking the finite difference
from <code>B</code> to <code>C</code> and from <code>D</code> to <code>C</code>, and extrapolating linearly on each axis - 
the hand-written extrapolation wouldn't include a contribution from from <code>A</code> at all.</p>
<p>We also need to negate the contribution from the grid points on the interior of the
grid - the areas that split the grid cell evenly before are now overlapping, and
the result we need is no longer any weighted average of the grid values. But,
imagining that we were in 3D, we could be still need to do <em>some</em> grid-cell-based
weighted-averaging, because we could be extrapolating on two axes (as in the 2D example)
while interpolating on a third axis.</p>
<p>Once we've zeroed-out the contribution from the inner point <code>A</code> and negated
the contributions from points <code>B</code> and <code>D</code>, we have another problem.</p>
<p>All three non-zeroed points <code>B</code>, <code>C</code>, and <code>D</code> share an overlapping region
which has an area that scales not linearly but quadratically with the position
of the observation point. This can't be part of the final interpolated result,
but it's easy enough to find the area of the nonlinear region and remove it.
This removal process is, conveniently, still an O(1) process for each
vertex of the grid cell, so while it makes extrapolation slightly slower,
it doesn't change the overall perf scaling.</p>
<p><img src="/assets/2023-11-24/2d_extrap_corrected.jpg" alt="2d geometric method extrapolated in corner region, with corrections" width="200"/></p>
<h3 id="extending-the-geometric-method-to-higher-dimensions">Extending the geometric method to higher dimensions</h3>
<p>Well, that's settled, right? It's not, but you get to find out the way I found out -
after slogging through a 3D implementation.</p>
<p>Let's see how it looks in 3D, interpolating to points on the interior of the grid.</p>
<p>To start, we'll look at a point that's on one face of the grid cell, so that
we can see what's going on without a forest of lines getting in the way,
and leaving two of the sub-cells un-shaded to unclutter the diagram.</p>
<p><img src="/assets/2023-11-24/3d_inner.jpg" alt="3d geometric method, a simple case on the interior" width="200"/></p>
<p>So far, so good. With a bit of staring and thinking, it's clear that this produces the
same behavior as the 2D version as the observation point moves around the face of the
cube.</p>
<p>As it moves to the interior of the cube, things get a little more detailed.</p>
<p><img src="/assets/2023-11-24/3d_inner_2.jpg" alt="3d geometric method, a simple case on the interior" width="200"/></p>
<p>Here I'm only shading two sub-cells again to keep the clutter down, but it's clear to see
that the partitioning still fills the space, and the volume of each sub-cell scales
linearly with the observation point's position on each axis.</p>
<p>Anyway, it's all working well so far! Let's see how the fixes from the 2D method hold up
under extrapolation in a side region.</p>
<p><img src="/assets/2023-11-24/3d_extrap_side.jpg" alt="3d geometric method, extrapolating in a side region" width="200"/></p>
<p>Looks good! Only two of the regions are shaded again, but from this, we can
already tell that negating the contribution from the points on the interior
of the grid will have the intended effect, same as in 2D.</p>
<p>Next, a look at the corner region, where we can exercise the fixes that zero-out
the contribution from the entirely-inside vertex and trim the nonlinear region.</p>
<h4 id="a-problem-in-higher-dimensions">A problem in higher dimensions</h4>
<p><img src="/assets/2023-11-24/3d_extrap_corner.jpg" alt="3d geometric method, extrapolating in a corner region" width="200"/></p>
<p>Uh-oh. Only shading the nonlinear region(s) this time, because that's the catch:
there isn't just one kind of nonlinear region, and the fix based on the 2D method
only capture the cubic region, not the quadratic regions.</p>
<h4 id="a-solution-in-higher-dimensions">A solution in higher dimensions</h4>
<p>It turns out, we can handle this, too - but not by enumerating all of the kinds of
nonlinear region in higher dimensions. Or at least, I don't know how to do that.
Instead, we can observe that all of the <em>linear</em> regions are of the same form,
the rectangular prisms projecting from each face of the cube. We can also make
a real claim that this will be the case in all higher dimensions, because any region
that grows in a direction not aligned with the coordinate axes will have a nonlinear
volume scaling, so all the linear regions must be aligned with the coordinate axes.</p>
<p>So, rather than removing all the bad regions, which only works well in 2D, we
can cycle through all the axes and take all the good regions that are
projected from the n-cube's faces. This works, including in higher dimensions,
and produces a true linear extrapolation outside the grid. However, it does
cost in performance: for the corner regions where this culling process is
required, the cost of evaluating an observation point scales like <code>O(2^ndim + ndim^2)</code>
instead of just <code>O(2^ndim)</code>.</p>
<p>For practical purposes, this is not too bad, but it is noticeable - about a factor of
2-4 reduction in throughput when extrapolating in corner regions, which
also breaks timing guarantees (not ideal for, say, embedded control systems).</p>
<p>With that, we have a method that generalizes to arbitrary dimensions, or at least to
the 10 dimensions I've tested it in, under both interpolation and extrapolation in every
type of region. And it can do this with no allocation (except, possibly, for somewhere
to put the output) and with stack usage that scales linearly in the number of dimensions.</p>
<h3 id="next-steps">Next Steps</h3>
<p>I am happy to report that due to the efforts of the cargo-semver-checks, release-plz, maturin, and PyO3
developers, I can gloss over the relatively painless process of releasing the rust library on crates.io,
generating python bindings, and releasing the python bindings on PyPI.</p>
<p>Instead of agonizing over tooling and processes, I can focus on extending the existing functionality.
Next on the list, in any particular order that I find inspiration, are:</p>
<ul>
<li>Proper multi-cubic (Hermite spline) interpolation</li>
<li>Vectorized alternatives to the multilinear methods here (for the high-throughput and timing-sensitive regimes)</li>
<li>Triangular and tetrahedral mesh interpolation</li>
<li>Perf optimizations of the python bindings for the existing multilinear interpolators</li>
</ul>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.f886a092.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.cd18aaf1.min.js"></script>
      
    
  </body>
</html>